'''
Created on Aug 24, 2017

@author: mroch
'''
from dsp.abstractstream import Streamer
import numpy as np
import scipy.signal as signal
from prompt_toolkit.layout.containers import Window

class DFTStream(Streamer):
    '''
    classdocs
    '''


    def __init__(self, frame_stream, window = None,
                 format="dB", dft_bins=None, calibration=None):
        '''
        DFTStream(frame_stream, window, format, calibration)
        Create a stream of discrete Fourier transform (DFT) frames using the specified sample frame stream.
        Only bins up to the Nyquist rate are returned in the stream
        Optional arguments:
        
        window - Vector of length frame_stream.
        format - DFT output:  
            "complex" - return complex DFT results
             "dB" [default] - return power spectrum 20log10(magnitude)
             "mag^2" - magnitude squared spectrum
        dft_bins - If larger than frame size, permits interpolated resolution to more frequencies,
            otherwise has no effect
        calibration - not yet implemented
        '''
        
        self.format_types = {"complex" : 0,
                             "mag^2" : 1,
                             "dB" : 2}
        self.framer = frame_stream
        self.frame_len = frame_stream.get_framelen_samples()
        try:
            self.format = self.format_types[format]
        except KeyError:
            raise ValueError("Unknown format {}.  Use one of [{}]".format(
                format, ", ".join(self.format_types.keys())))
             
        
        if dft_bins:
            # Use DFT length requested by user            
            if dft_bins < self.framer_len:
                raise ValueError("dft_bins must be >= {} frame length".format(frame_stream.__class__))
            self.dft_bins = dft_bins
        else:
            self.dft_bins = self.frame_len
        
         
        if not window:
            self.window = signal.get_window("hamming", self.frame_len)
        else:
            self.window = window
           
        if calibration:
            raise NotImplemented
        
        self.bins_Nyquist = np.floor(self.dft_bins/2)
        if self.format == self.format_types["complex"]:
            self.bins_Hz = np.arange(self.dft_bins) / self.framer.get_Fs()
        else:
            # Other types only return to Nyquist
            self.bins_Hz = np.arange(np.floor(self.bins_Nyquist)) / self.bins_Nyquist * frame_stream.get_Nyquist()
        
        self.bins_N = self.bins_Hz.shape[0]
         
    def shape(self):
        "shape() - Return dimensions of tensor yielded by next()"
        return np.asarray([len(self.bins_N), 1])
    
    def size(self):
        "size() - number of elements in tensor generated by iterator"
        return np.asarray(np.product(self.shape()))
    
    def get_Hz(self):
        "get_Hz(Nyquist) - Return frequency bin labels"
        return self.bins_Hz
            
    def __iter__(self):
        self.frame_it = iter(self.framer)
        return self
    
    def __next__(self):
        values, t, tstamp = next(self.frame_it)
        
        windowed = values * self.window
        complexspectrum = np.fft.rfft(windowed, self.dft_bins)  # DFT of real values
        if self.format == 0:
            result = complexspectrum
        elif self.format == 1:
            result = complexspectrum * np.conj(complexspectrum)            
        else:
            result = 20 * np.log10(np.abs(complexspectrum))

        return result[0:self.bins_N], t, tstamp
        
    def __len__(self):
        "len() - Number of tensors in stream"
        return len(self.framer)

        
        
        
    
        